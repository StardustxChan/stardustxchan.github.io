<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  <title>[笔记] 2017 - 黑马 C | 将进酒</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="详尽的视频教程笔记.">
<meta property="og:type" content="article">
<meta property="og:title" content="[笔记] 2017 - 黑马 C">
<meta property="og:url" content="http://yoursite.com/2018/12/14/笔记-2017-黑马-C/index.html">
<meta property="og:site_name" content="将进酒">
<meta property="og:description" content="详尽的视频教程笔记.">
<meta property="og:updated_time" content="2018-12-14T10:34:41.038Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[笔记] 2017 - 黑马 C">
<meta name="twitter:description" content="详尽的视频教程笔记.">
<meta name="twitter:creator" content="@stardust_s2@live.com">
  
    <link rel="alternate" href="/atom.xml" title="将进酒" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.png">
  
  
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">将进酒</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一剑霜寒十四州</a>
        </h2>
      
      <span id="busuanzi_container_site_uv" style="color:#FFF">
           <span id="busuanzi_value_site_uv"></span> 
        </span>
    </div>
    <div id="header-inner" class="inner">
      
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">所有文章</a>
        
          <a class="main-nav-link" href="/tags/产品/">产品文章</a>
        
          <a class="main-nav-link" href="/tags/特级厨师的鸡汤/">深层思考</a>
        
          <a class="main-nav-link" href="https://www.instagram.com/stardust_s2/">Instagram</a>
        
          <a class="main-nav-link" href="https://space.bilibili.com/4612745/#/">哔哩哔哩</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-笔记-2017-黑马-C" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/14/笔记-2017-黑马-C/" class="article-date">
  <time datetime="2018-12-14T10:33:06.000Z" itemprop="datePublished"></time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [笔记] 2017 - 黑马 C
    </h1>
  

        
      </header>
    
    <div class="article-entry" itemprop="articleBody">

      
        <p>详尽的视频教程笔记.<br><a id="more"></a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型的本质:  固定内存块大小的方式.<br>内存上:  数组名+1 得到下一个元素, &amp;数组名+1 得到下一个数组的大小(无意义).</p>
<ul>
<li>void 无类型, 就无法确定分配的内存大小, 因此 void 类型的变量会报错. </li>
</ul>
<ol>
<li>万能指针:  ‘void *变量’ 指针可以确定大小. 很多没有返回值的内置函数完成后, 返回的就是这个 void 指针记录调用函数前的程序内存地址, 之后程序从那个地址继续运行.</li>
<li>编程最好明确所有东西的类型, 所以 ‘没返回值的函数’ 返回值上必须写 void.<br>func(void) 表示函数拒绝接收参数, 不需要参数的函数应该写成这样<br>func(void *Point), 表示函数的参数是任意类型的指针, 适用于 memcpy 可用于所有类型拷贝的函数</li>
</ol>
<p>变量本质是一段连续内存的别名<br>字符格式的 \0 == 数字格式的 0, ‘\0’ == 0.   “\0”是字符串</p>
<h2 id="内存四区-重要"><a href="#内存四区-重要" class="headerlink" title="内存四区 (重要)"></a>内存四区 (重要)</h2><ul>
<li>堆:  手动使用的内存空间<br><strong>类型 <strong><strong>新定义的指针名 = (类型 </strong></strong>)malloc( sizeof(下一级类型 ***))</strong></li>
<li>栈:  程序局部变量, 分为 ‘main() 的栈’ 和 ‘调用函数的临时栈’</li>
<li>全局区 global:  包含文字常量和全局变量还有静态变量, 多指针指向相同内容, 提高利用率.</li>
<li>代码区<h2 id="画图-重要"><a href="#画图-重要" class="headerlink" title="画图 (重要)"></a>画图 (重要)</h2><em>凡事要画出四区图来分析程序</em></li>
</ul>
<ol>
<li>画图分清楚谁在哪里<br>char <em>p = ‘Sx’;  在栈区的指针指向一个放在全局区的字符串<br>char </em>q = ‘Sx’;  在栈区的另一个指针指向同一个全局区的字符串<br>由于全局区的效率策略, 第二个相同字符串不会重复创建, 只是让 p 和 q 都指向 ‘Sx’</li>
<li>变量的生命周期<br>char * get_str(){                <strong>返回 ‘指向 char 类型的指针’ 的地址</strong><blockquote>
<p>下图分析1<em>常量str</em>char strPoint_Str = “定义的是变量的字符串, 这个会被返回全局区地址”<br>下图分析2<em>变量 str</em>char str[] = “定义的是常量的数组名, 会返回函数临时栈区地址”;<br>全局区有’ ‘Sx\0’, 定义不是字符串, 定义的不是字符串, 定义的不是字符串,  因此, 函数临时栈区也会拷贝一份 ‘Sx\0’<br>用不着图分析  char <em>tmp = (char </em>)malloc()<br><strong>tmp 函数结束就释放, 堆区不会释放, 堆区的地址返回有效</strong></p>
<pre><code>return str;}        __因为是数组不是字符串, 所以返回的是函数临时栈区的地址__
</code></pre></blockquote>
</li>
</ol>
<p>char *p;            p = get_str()       <strong>乱码, 临时栈区已释放</strong><br>char buf[];         strcpy(buf, get_str()); <strong>不确定, 可能乱码, 也可能大函数拷贝时内部小函数的内存还在</strong></p>
<p>栈是往下生长, 堆是往上生长. 栈中的数组是往上生长</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>char buf3[] = “abcd”;       C 语言没有字符串类型, 只能用 char[] 代替. buf3 作为字符数组 有5个字节, 作为字符串有 4个字节<br>char str[100] = {0};      要有结束符 0 </p>
</blockquote>
<p>sizeof(字符串类型) 的大小，包括’\0’；strlen(字符串类型) 长度不包括‘\0’（数字 0 和字符‘\0’等价）。</p>
<h2 id="声明和定义区别"><a href="#声明和定义区别" class="headerlink" title="声明和定义区别"></a>声明和定义区别</h2><ol>
<li>一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。</li>
<li>没{}的函数叫做定义, 有{}的函数叫声明</li>
<li>正数的原码, 反码, 补码都相同. 负数的反码是原码的取反, 补码 = 反码 +1</li>
<li>当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位。<h2 id="scanf函数与getchar函数"><a href="#scanf函数与getchar函数" class="headerlink" title="scanf函数与getchar函数"></a>scanf函数与getchar函数</h2>getchar是从标准输入设备读取一个char。<br>scanf通过%转义的方式可以得到用户通过标准输入设备输入的数据。<br>gets(str)与scanf(“%s”,str)的区别：<br> gets(str)允许输入的字符串含有空格<br> scanf(“%s”,str)不允许含有空格<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1>指针指向谁，就把谁的地址赋值给指针<br><em>放在=左边, 给内存赋值, 写内存
</em>放在=右边, 取内存的值, 读内存<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>是一个结构体, 包含三个元素</li>
<li>指针的名字, 一般叫 p q</li>
<li>指针自己的地址, 对二级指针这个属性才有意义</li>
<li>指针内存放的内容, 是一个 0x?????? 的数值. </li>
<li>二维数组是矩阵, 二级指针只是指向指针的指针</li>
<li>常量指针和变量指针.  <em>a[], a 是常量指针, 只能 a+1, 不能 a++, 区别于手动定义的变量指针 p可以 p++</em><h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2></li>
<li>目的:  运行一个函数, 在函数内一次性改变多个 ‘传入实参的具体值’</li>
<li><blockquote>
<p>类型 <em>p= &amp;XXXXX 初始化定义, 要把 ‘类型 </em>‘ 看成一个整体, 实际上是赋值操作 ‘新建指针自己的内存=’要指向的人’ 的地址</p>
</blockquote>
</li>
<li><strong>先声明, 再赋值地址指向, 才能用 * 修改指向的内容. 不能操作没有指向的野指针</strong></li>
<li>取出:  *p 相当于,  操作 ‘p 内存放的地址所在的内存’</li>
<li>取出格式, 一定要告诉编译器那个地址的内存是什么类型, 反向的理解是, 内存按照什么规则来解析,<br><em>例如以%s的 char 类型解读的话, 就要遵守 char 读到\n 为止的规则, 传入 &amp;str[x] 或 p, 输出 str 第 x 个字母之后的所有char, 直到最后的结束符.</em><blockquote>
<p>printf(“%s”, 一个(char <em>)类型的 p1);   会打印直到\0<br>printf(“%c”, 一个(char </em>)类型的 p1);   会打印第一个 char</p>
</blockquote>
</li>
</ol>
<ul>
<li>strcpy(p, ‘some string’) 方法是给 p 指向的 ‘char str[]内存’ 拷贝,<br><strong>省略<em> 的原因是这个函数构造就是传入地址参数, 内部自行 </em>传入的参数</strong></li>
<li>静态只读字符串本身是 ‘指向在静态区第一个字母的地址’ 的栈指针,const char “hello” ,  所以可以 &gt; char *p = “hello”, 但是修改静态字符串会报错, 要修改只能用 str[]. </li>
<li>*<em>p = </em> p[], <strong>某些情况 <em> 和 [] 等价, &amp;的对立面是 </em>/[]</strong><pre><code>1. 作为函数参数时, 因为传入的是单个地址, 随意替换
2. 参数以外的正确用法:  
    1. &gt; char *str[] = {&quot;hello&quot;, &quot;hi&quot;}
    2. &gt; char * *p = str = &amp;str[0];  二级指针指向的地址 = 一级指针地址
3. 参数以外的错误用法: &gt; char * *str =  {&quot;hello&quot;, &quot;hi&quot;}
</code></pre></li>
<li>a+1 = &amp;a[1], a = &amp;a[]</li>
<li>char *a[3]= {“hello”, “hi”, “hei”} = 保存了 ‘三个字符串的首元素’ 的指针</li>
</ul>
<h2 id="通过函数改变实参的方法"><a href="#通过函数改变实参的方法" class="headerlink" title="通过函数改变实参的方法"></a>通过函数改变实参的方法</h2><p><em>要改 num, 执行修改的函数(参数 </em> p), 调用函数实参(&amp;num)*</p>
<ol>
<li>众所周知, 函数内部只能复制参数生成临时变量, 无法改变传入的实参的具体值</li>
</ol>
<ul>
<li>指针传递参数的用法:  <pre><code>1. 函数定义:  &gt; void func ( char *p) __注意这个是新建的指针, 其值等于一个地址值__
2. 函数传参实际调用:  &gt; func ( p 或者 &amp;p[0]) __总之传入地址值)
</code></pre></li>
</ul>
<ol>
<li>因此要改变传入的实参, 只能把 &amp;p 的地址传入函数, 函数内 ‘p = malloc 的堆地址’, 被调用函数是在heap上分配内存而非stack上<br> //不要轻易改变形参的值, 要引入一个辅助的指针变量. 把形参给接过来…..<br>int copy_str6(char <em> from )<br>{<br> //</em>(0) = ‘a’;<br> char <em>tmp = from;<br> tmp = malloc;
 </em>from = tmp</li>
<li>正确格式:   <ol>
<li>定义函数格式:  func( int *p ){}, </li>
<li>使用函数格式:  func(&amp;num) 这个叫做传地址, 传数组名也可以因为是个常量=首元素地址</li>
</ol>
</li>
<li>错误使用格式:  func( p ), 这个叫做传变量, 即便传的是记录地址的变量也不可以</li>
<li>错误使用格式:  func( a[]/a[100]/*a), 传了个形参, 编译器看来还是指针变量</li>
<li>面试题问法:  上述传入的 sizeof,  a[] = a[100] = * a = 一个指针的大小</li>
</ol>
<p>传地址:  函数定义时的形参比调用时的形参多一个 *, 就是在’地址作为参数传入’的时刻, 新建 ‘函数临时变量指向实参’ 的关系.</p>
<blockquote>
<p>高一级传入:  int <strong>b;   fun(int *</strong>a);     fun(&amp;b);<br>传变量:  平级传入.  要搞事只能 malloc在堆, 然后返回地址给 p, 释放临时变量也没事.<br>平级传入:  func(char *p);     func(p);</p>
</blockquote>
<blockquote>
<p>typedef int A[9];<br>A b;          //相当于, 去掉 typedef, b 替换到 A 的位置</p>
</blockquote>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>每个元素都是指针<br><strong>指针指向谁, 就把谁的地址给指针</strong></p>
<blockquote>
<p>char <em>a[] = {};           []的优先级比 </em>高 </p>
</blockquote>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>指向数组的指针, 指针一跳是一整个数组的长度<br>数组名a是数组首元素的起始地址，但并不是数组的起始地址。</p>
<blockquote>
<p>int a[10] = {0}           //最终指向的数组实例<br>typedef int A[10];    // 为了设定指针类型, 先定义数组类型. int 和实例类型 int 要匹配.<br>A *p = NULL;          //数组指针类型<br>p = &amp;a                    //&amp;a 是整个数组首地址,  a 是数组首元素地址. 值相同, 每一跳大小不同</p>
</blockquote>
<p>使用时 (<em> p)[i], 优先级
</em>常用的类型定义方式*</p>
<blockquote>
<p>typedef int (*Point)[10]; //定义类型MyPointer 为指向int[10]类型的指针<br>Point q;<br>q = &a;</p>
</blockquote>
<p><em>常用的变量定义方式</em></p>
<blockquote>
<p>int (*q)[10];     //q 是一个指针, 指向一个数组<br>q = &amp;a</p>
</blockquote>
<p><strong>不论怎么变, 只要注意, 声明的数组名*q 要指向 ‘第 0 个元素地址’, 这样一跳才正常</strong><br>一维数组:  ‘第0个元素地址’ = (数组名 + 0个), </p>
<blockquote>
<p><em>q = 数组名, q = &amp;数组名<br>二维数组:  ‘第0个元素地址’ = ‘第0行第0个元素地址’ = </em>(数组名 + 0行) + 0列<br>也就是, <em>q = </em>数组名, q = 数组名</p>
</blockquote>
<p>一维数组的 a 和 &amp;a 值一样, 但是每一跳的内存大小不同<br>二维数组的 a =首行地址，和首行首元素地址 <em>a 的值是一样, 然而他们的 ++, 一跳跳的内存大小不同<br>第 i 行首地址 = a + i = a[i]<br>第 i 行第 j 个元素地址 = </em>(a+i) +j = &amp;a[i][j]<br>第 i 行第 j 个元素值 = <em>( </em>(a+i) +j) = a[i][j]</p>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><p>sizeof(首元素地址) = 这个元素所在序列的大小<br>sizeof(数组名) = 一根指针的大小</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ol>
<li>struct xxx 两个单词合起来才是结构体类型</li>
<li>结构体内定义的变量不能赋值, 因为没有分配空间</li>
<li>新建一个结构体的实例 <pre><code>* &gt; struct xxx *p, 刚刚定义的时候 p 是一个野指针
* &gt; p = &amp;tmp, 指针要有指向, 栈, 堆, string 都可以
* &gt; p-&gt;age = 18, 指针结构体的用法
* (&amp;tmp)-&gt;age == ( *p).age, tmp 是正常的结构体实例名, p 是指针结构体实例名
</code></pre></li>
<li>初始化赋值一个新的结构体实例:  &gt; struct Student sx = {22, “Sx”, }, 赋值的属性会按照 ‘结构体属性定义时的顺序’ 赋值.</li>
</ol>
<h2 id="指针传参-结构体版"><a href="#指针传参-结构体版" class="headerlink" title="指针传参, 结构体版"></a>指针传参, 结构体版</h2><ol>
<li>定义函数  &gt; void func(const struct Student  *p){}    <pre><code>__接收的是一个地址, 并把地址赋值给新建的结构体指针.
不修改地址本身就加上 const, 还要注意 const 的位置__
</code></pre></li>
<li>要传的参数:  &gt; struct Student sx = {22, “sx”}</li>
<li>调用函数:  &gt; func( &amp;sx )  <strong>传入一个地址参数</strong></li>
</ol>
<h3 id="结构体内-包含指针成员"><a href="#结构体内-包含指针成员" class="headerlink" title="结构体内, 包含指针成员"></a>结构体内, 包含指针成员</h3><p>sx.name = (char <em>)malloc( sizeof(char) </em> (strlen(“stardustx”) + 1) )<br>分配的空间大小 = 每个char字的大小 * (存储内容的长度 + 结束符)<br>释放: 先释放 name, 再释放指针</p>
<h3 id="结构体提高"><a href="#结构体提高" class="headerlink" title="结构体提高"></a>结构体提高</h3><p>定义结构体时不能赋值, 因为定义不分配内存.</p>
<blockquote>
<p>Student <em>p = (Student </em>)malloc()<br>或者 &gt; struct Student <em>p = NULL;  p = &Sx;指向一个实例<br>一般用 Student.age, 闲得蛋疼等价于 (&amp;Student)-&gt;age<br>__指针用:  p-&gt;age 用法相当于 ( </em>p).age__</p>
</blockquote>
<blockquote>
<p>Teacher tmp[老师个数];    等价于     &gt; Teacher <em>tmp = NULL;   tmp = (Teacher </em>)malloc(老师个数 * sizeof(Teacher)); </p>
</blockquote>
<blockquote>
<p>p = tmp; 间接赋值是指针存在最大意义, tmp 中存放 malloc 函数返回的堆地址, 赋值给一级指针 p</p>
</blockquote>
<p>9.4 typedef<br>typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。</p>
<p>    与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值<br>    #define发生在预处理，typedef发生在编译阶段</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>错误 typedef struct player{<br>    int age;<br>    struct player next;};       <strong>结构体本身没定义完, 内存大小不确定. 递归定义多捞啊</strong><br>正确 typedef struct player{<br>    int age;<br>    struct player *next;};      <strong>指针大小是固定的, 可以指向下一个自己的类型</strong></p>
</blockquote>
<blockquote>
<p>开始连接 ALLMight.next = &Sx;</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用指针指向, 替代新建节点=左边的名字, 有指针就不用名字了</span></span><br><span class="line">    player *head = <span class="literal">NULL</span>;</span><br><span class="line">    head = (player *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(player));        <span class="comment">//两行建立一个节点在堆, 熟练</span></span><br><span class="line">    player *currentPlayerPoint = head;              <span class="comment">//地址 = 地址, 两个指针都指向头</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入数据"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>; &#125;</span><br><span class="line">        player *NewPlayerPoint = <span class="literal">NULL</span>;</span><br><span class="line">        NewPlayerPoint = (player *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(player));  <span class="comment">//两行建立一个节点</span></span><br><span class="line">        NewPlayerPoint-&gt;age = data;     <span class="comment">//新节点赋值</span></span><br><span class="line">        currentPlayerPoint-&gt;next = NewPlayerPoint;</span><br><span class="line">        currentPlayerPoint = NewPlayerPoint; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>先定义类型<blockquote>
<p>typedef 返回值类型 (*pFunc) (参数);<br>PFunc p2 = fun;       函数指针 p2 指向, PFunc 类型的 fun函数<br>p2() 等价于 fun()</p>
</blockquote>
</li>
<li>直接定义<blockquote>
<p>int (*pFunc)(参数) = 函数实例名;</p>
</blockquote>
</li>
<li>实际使用<br>创建条件[], 函数指针[], 创建一个字典, dict{ 条件: 函数指针}<br>for 匹配条件, 调用对应的函数指针</li>
<li>回调函数实现多态<blockquote>
<p>void BigFunc ( int x, int y, int(*SmallFunc)(int a, int b)){</p>
<pre><code>int x = SmallFunc(x, y);}  //里面只能用 BigFunc 的参数, SmallFunc 的参数只是声明
</code></pre><p>把小函数名当做地址传入大函数, 大函数可以调用任意传入的小函数, 实现多功能大函数</p>
</blockquote>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote>
<p>void 外域:: 内部函数名(){}, 如果要在’外域’的外部声明内部函数, 类外定义内部函数就要这样格式<br>data 区域存放静态量, 在函数没调用之前就存在了, 所以不能 &gt; static int j = var<br>static 的变量放到 const 的 data 区域, 第二次新建一个 static 的同名变量会失效, static 变量直到程序结束才释放.</p>
</blockquote>
</li>
</ul>
<p>全局变量要先赋值定义才能用, 和函数的模式一样<br> 只能定义一次 &gt; int a=1;  可以多次声明 &gt; extern int a;<br> <strong>推荐定义的时候直接 a=0 , 赋值初始化</strong></p>
<p>extern 普通全局变量是所有头文件和 main 文件都能<em>连通使用</em><br>static 全局变量是只能在声明的<em>本文件</em>使用![屏幕快照 2018-11-09 11.46.51-sqd](media/</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>程序执行前, 有几个内存分区已经确定</p>
<blockquote>
<p>size a.out            , 查看分区大小</p>
<ul>
<li>text 代码区:  只读, 函数</li>
<li>data: 初始化的数据, 全局变量 extern, static 静态变量, 文字常量</li>
<li>bss:  没有初始化的数据, 全局变量, static 变量</li>
</ul>
</blockquote>
<p>程序运行后, 除了以上的内存分区, 还有两个分区即刻加载</p>
<ul>
<li>stack:  自动管理, <em>递归或分配过大内存, 容易越界</em></li>
<li>heap:  手动申请释放, 程序结束系统自动回收所有. <em>不结束程序, 一直占用</em></li>
</ul>
<h3 id="mem-类函数的使用"><a href="#mem-类函数的使用" class="headerlink" title="mem 类函数的使用"></a>mem 类函数的使用</h3><ol>
<li>语法: memxxx( 目标地址, 源文件地址, 拷贝多少内存)</li>
<li>memset, 用来清空数据</li>
<li>memcpy, 无视结束符的拷贝, strncpy 会被结束符结束拷贝. 可能会出现内存重叠错误</li>
<li>memmove, 不会内存重叠的移动</li>
<li>memcmp, 查看内存是否相等</li>
</ol>
<h3 id="代码操作内存"><a href="#代码操作内存" class="headerlink" title="代码操作内存"></a>代码操作内存</h3><blockquote>
<p>int <em>p;               p = (int </em>)malloc(sizeof(int));</p>
<ol>
<li>malloc 分配 sizeof(int) 这么大的堆区内存空间, 成功的话, 返回堆区首元素地址</li>
<li>返回的地址是 (void <em>)类型, 所以要转换成和指针类型匹配的 (int </em>) 类型</li>
<li>返回首元素内存地址给 *p</li>
</ol>
</blockquote>
<blockquote>
<p>if(p != NULL){<br>        free(p);            <strong>p 指向的那块内存, 程序放弃使用权交还给系统</strong><br>        p=NULL}         <strong>把上述内存的入口删除</strong></p>
<ol>
<li>第一步, 不是释放 p 变量, 而是释放 ‘p指针内存放的地址’ 指向的内存.  释放的意思是用户放弃使用权, 交给系统回收</li>
<li>第二步, 把指针内存放的内容赋值为空</li>
<li>同一块内存被多个指针, 连续释放多次也会报错, 用 if(p != NULL) 判断</li>
</ol>
</blockquote>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>用 <em>fp 指针访问 File 文件, </em>fp  不直接指向文件, 而是会自己调用了 fileOpen()<br>fp 是一个叫做 ‘句柄’ 结构体, 内部包含 {缓冲区, 文件描述符, 等} 成员属性<br>因此并不能直接操作 fp 指针, 而是调用文件库函数来操作 fp</p>
<ol>
<li>打开和关闭和判断结尾<br> <strong>windows 平台的打开关闭是 wb, rb</strong><blockquote>
<p>fclose(stdout);  关闭printf 输出<br>perror(“ 自定义 “);  打印库函数调用失败的原因<br>fp = fopen( 路径, 读写权限 ).   fopen 自己去安排 File 结构体, 完成操作, 返回地址给 fp<br>feof(fp):   因为这个函数不会移动光标, 所以要__先fget(fp)读 fp, 再调用这个函数, 如果到文件结尾, 返回真. 读文件读到末尾是  EOF==-1.  类似字符串的结尾是 \n</p>
</blockquote>
</li>
<li>读文件<ul>
<li>fgetc(), fputc()读写单个字的函数, 都会自动移动光标</li>
<li>fgets(), fputs() 按行读写<blockquote>
<p>memset(buf, 0, sizeof(buf))        先清空, 因为 fgets 失败的话, 缓冲区还是保留上次<br>fgets( 缓存到哪buf, sizeof(缓存到哪buf), 从’fp 或者 stdout’ 读)</p>
</blockquote>
</li>
<li>按块读写<blockquote>
<p>fwrite( str, sizeof(str)单个块大小, 块个数, 写入文件)<br> 读文件的块数目= fread( 读入缓存在 buf, 1每次读一块, sizeof(buf)单个块大小, 源文件)<br>避免要写的超过储存, 多用于每次写一个块, mdzz</p>
</blockquote>
</li>
</ul>
</li>
<li>写文件<blockquote>
<p>fputc(‘ 单个字符’, 打开的文件 fp 或者屏幕sdtout)         写文件的函数, 每次写一个字符, 自己写循环写入</p>
<ul>
<li>格式提取内容<br>sscanf(“1stardustx6”, “%1d%9s%1d”, &amp;num1, sx, &amp;num2);, 把 参数一 中的内容, 按照第二个参数的格式分拆, 赋值给后面的参数. 因为要改参数本身, 所以后面的都是地址: 数字需要加&amp;, 字符串本身就是首地址的指针</li>
<li>提取后重组内容<br>sprintf(buf, “%d\n”, str),  把 str 格式化为字符串且加上换行, 再赋值给 buf</li>
<li>写入文件<br>fprintf( 写入目标, “格式”, a, b, c)</li>
</ul>
</blockquote>
</li>
<li>文件光标移动函数<blockquote>
<p>fseek(fp, 0, SEEK_SET);   移动光标到相对于开头 0 个字节<br>fseek(fp, 0, SEEK_END);   移动光标到结尾<br>long size = ftell(fp);            获取光标所在位置到开头的大小</p>
</blockquote>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3>要写文件的指令实际上存在缓冲区, 有以下 4 种方法, 从缓冲区真正写到文件<ol>
<li>缓冲区满, 自动写入, 不同 OS 缓冲区不一样</li>
<li>正常 fclose()</li>
<li>fflush(), 迫不得已手动刷新</li>
<li>程序正常结束</li>
</ol>
</li>
</ol>
<h3 id="程序编译步骤"><a href="#程序编译步骤" class="headerlink" title="程序编译步骤"></a>程序编译步骤</h3><p>C代码编译成可执行程序经过4步：<br>1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法<br>2）编译：检查语法，将预处理后文件编译生成汇编文件<br>3）汇编：将汇编文件生成目标文件(二进制文件)<br>4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *theStr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*theStr ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 首先, 递归之上的语句会执行第一次, 然后随递归执行递归次</span></span><br><span class="line">    <span class="keyword">if</span> (reverse(theStr+<span class="number">1</span>) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 2. 第二, 把递归放在条件上, 就会一直自我循环直到满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 最后, 递归之下的语句会循环递归次. </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>, *theStr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/14/笔记-2017-黑马-C/" data-id="ck8in98i0000ysfgj7d9v3v7w" class="article-share-link">Love Yourself</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/14/笔记-MindTalk-笔记合集/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [笔记] MindTalk 笔记合集
        
      </div>
    </a>
  
  
    <a href="/2018/09/05/纳纹/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">商品 ADC 面试总结</div>
    </a>
  
</nav>

  
  
</article>







</section>
        
      </div>
      <footer id="footer">

  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Sx    
        ,    powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
    
  </div>
</footer>


<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">所有文章</a>
  
    <a href="/tags/产品/" class="mobile-nav-link">产品文章</a>
  
    <a href="/tags/特级厨师的鸡汤/" class="mobile-nav-link">深层思考</a>
  
    <a href="https://www.instagram.com/stardust_s2/" class="mobile-nav-link">Instagram</a>
  
    <a href="https://space.bilibili.com/4612745/#/" class="mobile-nav-link">哔哩哔哩</a>
  
</nav>
    

<script src="http://apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
<script type="text/javascript">
//<![CDATA[
if (typeof jQuery == 'undefined') {
document.write(unescape("%3Cscript src='/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E"));
}
// ]]>
</script>




<script src="/js/script.js"></script>



  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"scale":0.1,"model":{"scale":0.7,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":180,"hOffset":-80,"vOffset":-20,"superSample":2,"scale":7},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.9,"opacityOnHover":1}});</script></body>
</html>